{
    "collab_server" : "",
    "contents" : "#' @title Method to predict according to the regular difference time series model.\n#'\n#' @description This method implements the predicted value and their standard deviation according to\n#' the regular difference time series model \\eqn{(1-B)y_{t}=a_{t}}{(1-B)y<sub>t</sub>=a<sub>t</sub>}.\n#'\n#' @param x object upon which the prediction will be made.\n#'\n#' @param VarNames character vector with the variable names for which the prediction will be made;\n#' by default it is NULL.\n#'\n#' @param forward integer indicating the number of periods ahead when the prediction will be made;\n#' by default it is 2L.\n#'\n#' @return It returns a list with components Pred and STD, containing the point prediction and the\n#' estimated standard deviations, respectively. Depending on the class of the input parameter x, it\n#' returns:\n#'\n#' \\itemize{\n#'  \\item For input class vector, it returns numeric vectors.\n#'  \\item For input class matrix, it returns matrices.\n#'  \\item For input class StQList, it returns list whose components are\n#'   data.tables.\n#' }\n#'\n#' @examples\n#'\n#' # Predicting one and two months ahead in time\n#' data(Example1.TS)\n#' RegDiffTSPred(Example1.TS, forward = 1L)\n#' RegDiffTSPred(Example1.TS, forward = 2L)\n#'\n#' # Predicting upon a times series with many NA values\n#' data(Example2.TS)\n#' RegDiffTSPred(Example2.TS, forward = 1L)\n#'\n#' \\dontrun{\n#' # With an object of class StQList\n#' data(StQListExample)\n#' VarNames <- c('ActivEcono_35._6._2.1.4._0', 'GeoLoc_35._6._2.1._1.2.5.')\n#' RegDiffTSPred(StQListExample, VarNames)\n#' }\n#'\n#' @import forecast imputeTS data.table StQ RepoTime parallel\n#'\n#' @export\nsetGeneric(\"RegDiffTSPred\", function(x, VarNames, frequency = 12L, forward = 2L){\n    standardGeneric(\"RegDiffTSPred\")})\n#'\n#' @rdname RegDiffTSPred\n#'\n#' @export\nsetMethod(\n    f = \"RegDiffTSPred\",\n    signature = c(\"vector\"),\n    function(x, VarNames, frequency = 12L, forward = 2L){\n\n        x <- as.numeric(x)\n        x[is.infinite(x)] <- NA_real_\n\n        if (all(is.na(x))) {\n\n            output <- data.table(Pred = NA_real_, STD = NA_real_)\n            return(output)\n\n        }\n\n        ini <- which.min(is.na(x))\n        last <- length(x)\n        x <- x[ini:last]\n\n\n        # vectors with not enough observations returns NA\n        if (length(x) == 0 | length(x[!is.na(x)]) <= 3) {\n\n            output <- data.table(Pred = NA_real_,STD = NA_real_)\n            return(output)\n\n        }\n\n        if (length(rle(x[!is.na(x)])$values) == 1) {\n            x <- imputeTS::na.kalman(x, model = 'auto.arima')\n        } else {\n            x <- imputeTS::na.kalman(x)\n        }\n\n        x <- ts(x, frequency = frequency)\n\n        fit <- Arima(x, order = c(0, 1, 0), seasonal = c(0, 0, 0))\n        out <- forecast::forecast(fit, h = forward)\n        std <- sqrt(out$model$sigma2)\n        output <- list(Pred = out$mean[forward], STD = std)\n        output <- data.table(Pred = output$Pred, STD = output$STD)\n        return(output)\n\n    }\n)\n#'\n#' @rdname RegDiffTSPred\n#'\n#' @export\nsetMethod(\n    f = \"RegDiffTSPred\",\n    signature = c(\"StQList\"),\n    function(x, VarNames, frequency = 12L, forward = 2L){\n\n        if (length(VarNames) == 0) stop('[RegDiffTSPred StQList] The input parameter VarNames must be specified.\\n')\n\n        x_StQ <- StQListToStQ(x)\n        VNC <- getVNC(getDD(x_StQ))$MicroData\n        IDQuals <- unique(VNC[['IDQual']])\n        IDQuals <- IDQuals[IDQuals != '' & IDQuals != 'Period']\n        DT <- dcast_StQ(x_StQ, ExtractNames(VarNames))\n        DT[, orderPeriod := orderRepoTime(Period), by = IDQuals]\n        setkeyv(DT, c(IDQuals, 'orderPeriod'))\n\n        if (length(VarNames) == 1) {\n\n            output <- DT[ ,RegDiffTSPred(get(VarNames), frequency = frequency, forward = forward),\n                          by = IDQuals]\n            setnames(output, c('Pred', 'STD'), paste0(c('Pred', 'STD'), VarNames))\n\n        } else {\n\n            n_cores <- floor(detectCores() / 2 - 1)\n            clust <- makeCluster(n_cores)\n\n            clusterExport(clust, c(\"VarNames\", 'frequency', 'forward', 'DT', 'IDQuals'), envir = environment())\n            clusterEvalQ(clust, library(data.table))\n            clusterEvalQ(clust, library(TSPred))\n\n            output <- parLapply(clust, VarNames, function(var){\n\n                out <- DT[ ,RegDiffTSPred(get(var), frequency = frequency, forward = forward), by = IDQuals]\n                return(out)\n\n            })\n\n            stopCluster(clust)\n\n            names(output) <- VarNames\n            output <- lapply(seq_along(output), function(n){\n                setnames(output[[n]], c('Pred', 'STD'), paste0(c('Pred', 'STD'), names(output[n])))})\n            output <- Reduce(merge, output)\n\n        }\n\n        return(output)\n    }\n)\n",
    "created" : 1531385494628.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "376586244",
    "id" : "38A00F63",
    "lastKnownWriteTime" : 1531386031,
    "last_content_update" : 1531386031754,
    "path" : "~/INE.Packages.v2/TSPred/R/RegDiffTSPred.R",
    "project_path" : "R/RegDiffTSPred.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}