{
    "collab_server" : "",
    "contents" : "#' @title Method to predict according to the stational difference time series model\n#'\n#' @description This method implements the predicted value and their standard deviation according to\n#' the regular difference time series model\n#' \\eqn{(1-B)^s y_{t}=a_{t}}{(1-B)^s y<sub>t</sub>=a<sub>t</sub>}.\n#'\n#' @param x object upon which the prediction will be made.\n#'\n#' @param StatDiff stational differences of the time series; by default it is 12L.\n#'\n#' @param forward integer indicating the number of periods ahead when the prediction will be made;\n#' by default it is 2L.\n#'\n#' @param VarNames character vector with the variable names for which the prediction will be made;\n#' by default it is NULL.\n#'\n#' @return It returns a list with components Pred and STD, containing the point prediction and the\n#' estimated standard deviations, respectively. Depending on the class of the input parameter x, it\n#' returns:\n#'\n#' \\itemize{\n#'  \\item For input class vector, it returns numeric vectors.\n#'  \\item For input class matrix, it returns matrices.\n#'  \\item For input class StQList, it returns list whose components are\n#'   data.tables.\n#' }\n#'\n#' @examples\n#'\n#' # Predicting one and two months ahead in time\n#' data(Example1.TS)\n#' StatRegDiffTSPred(Example1.TS, forward = 1L)\n#' StatRegDiffTSPred(Example1.TS, forward = 2L)\n#'\n#' # Predicting upon a times series with many NA values\n#' data(Example2.TS)\n#' StatRegDiffTSPred(Example2.TS, forward = 1L)\n#'\n#' # On a matrix\n#' Mat <- rbind(Example1.TS, Example2.TS)\n#' StatRegDiffTSPred(Mat, forward = 1L)\n#'\n#' \\dontrun{\n#' # With an object of class StQList\n#' data(StQListExample)\n#' VarNames <- c('ActivEcono_35._6._2.1.4._0', 'GeoLoc_35._6._2.1._1.2.5.')\n#' StatRegDiffTSPred(StQListExample, StatDiff = 9L, VarNames = VarNames)\n#' }\n#'\n#' @import forecast imputeTS data.table StQ RepoTime parallel\n#'\n#' @export\nsetGeneric(\"StatRegDiffTSPred\", function(x,  StatDiff = 12L, forward = 2L,\n                                         VarNames = NULL){\n    standardGeneric(\"StatRegDiffTSPred\")})\n#'\n#' @rdname StatRegDiffTSPred\n#'\n#' @export\nsetMethod(\n    f = \"StatRegDiffTSPred\",\n    signature = c(\"vector\"),\n    function(x,  StatDiff = 12L, forward = 2L, VarNames = NULL){\n\n        x <- as.numeric(x)\n        x[is.infinite(x)] <- NA_real_\n\n        if (all(is.na(x))) {\n\n            output <- data.table(Pred = NA_real_, STD = NA_real_)\n            return(output)\n\n        }\n\n        ini <- which.min(is.na(x))\n        last <- length(x)\n        x <- x[ini:last]\n\n\n        # vectors with not enough observations returns NA\n        min <- (last + forward) - 3 * StatDiff\n        if (length(x) == 0 | min < ini) return(list(Pred = NA_real_, STD = NA_real_))\n\n\n        if (length(rle(x[!is.na(x)])$values) == 1) {\n            x <- imputeTS::na.kalman(x, model = 'auto.arima')\n        } else {\n            x <- imputeTS::na.kalman(x)\n        }\n\n        x <- ts(x, frequency = StatDiff)\n\n        fit <- Arima(x, order = c(0, 1, 0), seasonal = c(0, 1, 0))\n        out <- forecast::forecast(fit, h = forward)\n\n        std <- sqrt(out$model$sigma2)\n        output <- list(Pred = out$mean[forward], STD = std)\n        output <- data.table(Pred = output$Pred, STD = output$STD)\n        return(output)\n    }\n)\n#'\n#' @rdname StatRegDiffTSPred\n#'\n#' @export\nsetMethod(\n    f = \"StatRegDiffTSPred\",\n    signature = c(\"StQList\"),\n    function(x,  StatDiff = 12L, forward = 2L, VarNames = NULL){\n\n        if (length(VarNames) == 0) stop('[StatRegDiffTSPred StQList] The input parameter VarNames must be specified.\\n')\n\n        x_StQ <- StQListToStQ(x)\n        VNC <- getVNC(getDD(x_StQ))$MicroData\n        IDQuals <- unique(VNC[['IDQual']])\n        IDQuals <- IDQuals[IDQuals != '' & IDQuals != 'Period']\n        DT <- dcast_StQ(x_StQ, ExtractNames(VarNames))\n        DT[, orderPeriod := orderRepoTime(Period), by = IDQuals]\n        setkeyv(DT, c(IDQuals, 'orderPeriod'))\n\n        if (length(VarNames) == 1){\n\n            output <- DT[ ,StatRegDiffTSPred(get(VarNames), StatDiff = StatDiff, forward = forward),\n                          by = IDQuals]\n            setnames(output, c('Pred', 'STD'), paste0(c('Pred', 'STD'), VarNames))\n\n        } else {\n\n            n_cores <- floor(detectCores() / 2 - 1)\n            clust <- makeCluster(n_cores)\n\n            clusterExport(clust, c(\"VarNames\", 'StatDiff', 'forward', 'DT', 'IDQuals'), envir = environment())\n            clusterEvalQ(clust, library(data.table))\n            clusterEvalQ(clust, library(TSPred))\n\n            output <- parLapply(clust, VarNames, function(var){\n\n                out <- DT[ ,StatRegDiffTSPred(get(var), StatDiff = StatDiff, forward = forward),\n                           by = IDQuals]\n                return(out)\n\n            })\n\n            stopCluster(clust)\n\n            names(output) <- VarNames\n            output <- lapply(seq_along(output), function(n){\n                setnames(output[[n]], c('Pred', 'STD'), paste0(c('Pred', 'STD'), names(output[n])))})\n            output <- Reduce(merge, output)\n\n        }\n\n        return(output)\n    }\n)\n",
    "created" : 1531386121926.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3421456739",
    "id" : "21A45A8A",
    "lastKnownWriteTime" : 1531386129,
    "last_content_update" : 1531386129771,
    "path" : "~/INE.Packages.v2/TSPred/R/StatRegDiffTSPred.R",
    "project_path" : "R/StatRegDiffTSPred.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}